import { constructModule } from './constructModule';
import { ENVIRONMENT } from './environment';
import { isNode } from './util/isNode';
import { log } from './util/logger';

type stringMap = { [key: string]: any };

/**
 * Asynchronously load and initialize asm module.
 *
 * @param {string} [binaryEndpoint] Provides endpoint to server to download binary module
 * (.wasm, .mem) via fetch when initialize module in a browser environment.
 * @param {ENVIRONMENT} [environment] Override running environment to load binary module.
 * This option is mostly for Electron's renderer process, which is detected as node.js env by default
 * but in case of would like to use fetch to download binary module.
 *
 * @returns {T} Factory function manages lifecycle of hunspell and virtual files.
 */
type moduleLoaderType<T> = (binaryEndpoint?: string, environment?: ENVIRONMENT) => Promise<T>;

/**
 * Runtime generated by requiring module satisfies runtimeModuleType.
 * `initializeRuntime` is injected via `constructModule` for awaitable module initialization.
 */
interface AsmRuntimeType {
  initializeRuntime: () => Promise<void>;
}

/**
 * Type of runtime module function. This is node.js asm module loaded via plain `require`,
 * internally emscripten should compile with MODULARIZE=1 option to loaded module via require returns
 * function to construct wasm module internally.
 *
 * For example,
 * ```
 * const asmLoader: runtimeModuleType = require('./lib/wasm/hunspell')
 * asmLoader(); //actually construct wasm module
 * ```
 */
type runtimeModuleType = (moduleObject: stringMap) => AsmRuntimeType;

type getModuleLoaderType = <T, R extends AsmRuntimeType>(
  factoryLoader: (runtime: R) => T,
  asm: { dir: string | null; runtimeModule: runtimeModuleType },
  module?: stringMap
) => moduleLoaderType<T>;

/**
 * Creates loader function to load and initialize wasm module.
 *
 * @param {(runtime: R) => T} factoryLoader Factory to create actual instance of implementation using loaded & initialized wasm runtime.
 *
 * @param {{dir: string | null, moduleLoader: Function}} asm Options to load and initialize runtime.
 * `moduleLoader` is wasm runtime loaded via plain `require` but compiled with MODULARIZED=1 preamble,
 * which should be function to accept asm module object to override.
 *
 * `dir` is ABSOLUTE DIR PATH to wasm / asm binary (.wasm, .mem). This is for node.js only since browser should rely on binary endpoint fetch always.
 * @param {{[key: string]: any}} [module] Stringmap object to be injected into wasm runtime for override / set additional value in asm module.
 *
 * @returns {moduleLoaderType<T>} Loader function
 */
const getModuleLoader: getModuleLoaderType = <T, R extends AsmRuntimeType>(
  factoryLoader: (runtime: R) => T,
  asm: { dir: string | null; runtimeModule: runtimeModuleType },
  module?: stringMap
) => async (binaryEndpoint?: string, environment?: ENVIRONMENT) => {
  const env = environment ? environment : isNode() ? ENVIRONMENT.NODE : ENVIRONMENT.BROWSER;
  const asmBinaryDir = env === ENVIRONMENT.NODE ? asm.dir : null;

  log(`loadModule: ${environment ? `using environment override ${environment}` : `running environment is ${env}`}`);
  log(`loadModule: will load wasm binary from ${asmBinaryDir ? asmBinaryDir : 'browser endpoint'}`);

  if (!binaryEndpoint && env === ENVIRONMENT.BROWSER) {
    throw new Error('Cannot download binary module without endpoint on browser');
  }

  const constructedModule = constructModule(module || {}, env, asmBinaryDir, binaryEndpoint);
  log(`loadModule: module object for asm runtime constructed`, constructedModule);
  const asmModule = asm.runtimeModule(constructedModule);

  await asmModule.initializeRuntime();
  log(`loadModule: initialized wasm binary Runtime`);

  return factoryLoader(asmModule as R) as T;
};

export { AsmRuntimeType, stringMap, runtimeModuleType, moduleLoaderType, getModuleLoaderType, getModuleLoader };
